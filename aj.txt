Web siters were static files,html pages, grphics and various other files.
A web app it is dynamic.
When a web appl prog runs on a server, it might not be containing proper html page.
that page might be a java apli, it might be a python appli,
So these applications are executed in the server and in the response,
these pages are going to generate your html page,
and this html page will be sent back to ur client.

Ur client, that is ur browser in response,
is always going to get an html page only.

Sometimes, when we r sending a req from client to server, we
might also send some data, so server will also read the data 
and tries to figure out reponse based on given data.

In web applications -- client sends a req,
req is handed to a web server.
Inside a web server there is an application which is always running.
the name of this appli  is web container.
This web container contains objects of all the servlets
that we are going to create which the user will be requesting.

That is the user req servelet, the servelet generates reponse,

Now every req that comes to a web container
is treated as a thread. So the amount of load coming on the processor reduces,
And its not going to create a thread because it has a thread pool,

Servlets--
it runs within web container. In our case it is,
Java Platform Enterprise Edition.
The web container implements Application Programming Interface.

Everything related to servelet is controlled by a web container.
i.e. creating objects of the servelet,calling method on the servelet,
giving back the response from the servelet,
everything is done by a web container.

So we as a programmer will only create a servelt.
We will not create new instance of servelet,
we will not call any method of the servelet,
So web container performs initial processing,
and selects the intended servelet to handle the req.
It controls the entire lifecycle of servelet.
browser send http request to ur web server,
web server gives it to web container,
Now based on the url, web container search for the
servelet that u r trying to req,
if it finds that servelt,
it tries to process that servelet,
handover the ersponse back, the response mostly will be html page.
which web container hands over to web server and which gives response to a client.



Based on the url,web con







requirement--
tomcat server installation -- donot install native one-- Tomcat 9.0.87 Released-- download-- binary distribution-- for core-- zip file-- extract-
-- start eclipse ide-- select workspace-- now first we need to add tomcat server and keep it ready--
so, windows-->show view-->servers--> close welcome window--->in the below part where output comes--> u can see servers
now click on the link no servers are available. Click this link to creATE new server--> in the dialog box click on apache server-->
--> the version that we r working is 9-->next-->
path where apache is installed, select that folder
i.e. D:\learning\apache-tomcat-9.0.87

now to start the server-- right click on Tomcat v9.0 Server at localhost[Stopped, Republish]-- start

server is active now, and within server web container is also active.

Now to test if we can reach our server , we will do little test--
now we r performing this activity on localhost only.
apache tomcat listens on server 8080--

So on the browser , write http://localhost:8080/

we r getting error page sent by apache tomcat.

error is ther becoz it doesnt know what to do on /.

now, going back to ide, double click on link--
and overview page will open related to server--

in that u have server location-- > click on use tomcat installation
--> press ctrl+s-- i.e. save it--> and restart server

now refresh http://localhost:8080/-- entire homepage is set.

now, creating 1st project-- file-->new-->dynamic web project-->
project name-- FirstApp-->finish

if u will expand this folder u will get required libraries.

for us the most important is firstapp->java resources-> src/main/java
All my servelet files will be inside it.
the same path we have in firstapp->src->main->java-- all the java files
will be part of this folder, all html files will be
part of webapp.

In order to run this application-->right click on FirstApp-->
-->run as server becoz i dont want to run this application
as standalone. I want to run it on the server.-->dialogue box-->
choose an existing server--see localhost written there--->tomcat v9.0-- started
-- click always use this server -->finish-->restart now-->ok

so we uploaded our entire project on server now.
see the url--

http://localhost:8080/FirstApp/


Now u can goto preferences--->u can even change browser-->
just search web browser--> use external web browser--> chrome
-->apply and close-->now run firstapp-> it will open on the chrome browser

Now we will design homepage--

homepage is page for url /

now see deployment descriptor firstapp-->
welcome pages-->
now the entire lifecycle of web server, we r not going to 
control it. So we need to provide some settings to my
web container that are related to application so that 
it knows what is to be done with this project.

for eg our home page if we r giving as /,
so which page is to be opened under which servlet,
that complete mapping we will be doing under
deployment descriptor, everything which data will go.

This deployment descriptor file is an xml file.
The name of this file is web.xml

Deployment Descriptor is XML file used by web container to define servlets match up with which URLs. It will also specify the landing page for the root of the application

Now to add the deployment descriptor file--
right click on first app-->java ee tools-->generate deployment descrptor stub--see under wen-inf folder

this is the xml file we need.

Now when u open this web.xml file-- below there are 2 tabs--
design and source

now right click web.xml-->open with generic text editor

Any 1 of the files present here can be your homepage.

So lets say index.html--
so how to add html file within ur project--

right click on project-->new html file--> Name it index.html

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
<h3>Welcome to first web application</h3>
</body>
</html>

save it and now run ur project

--
now lets say if I delete index.html file
right click on source to create new html file,
name it default.html

this is also my welcome file,

I can even create my own html welcome file.

from web.xml u can delete <welcome-file> part
and write--

home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
</body>
</html>


web.xml is like--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>FirstApp</display-name>
  <welcome-file-list>
    <welcome-file>home.html</welcome-file>
  </welcome-file-list>
</web-app>


now those who have installed eclipse java ee they donot need to do this otherwise-- search eclipse java ee on browser-- and install windowsx86

Tomserver is an application server.




Now in eclipse create a new workspace-- aj_try-- once it is launched u will see welcome msg with eclipse ide for enterprise java and web developers

---

now understanding http --

goto browser-->wikipedia india-->search-->right click inspect-->network-->name---> see request url--> request method is get-->
scroll down and see the response, accept (in accept it tells what all pages it can accept, so it can accept https)

now going to response-- the entire html page is sent back as response.

so while sending a request we follow a http protocol which we can see under headers, also remote addr-- addr of the m/c is going to server m/c



---

Deployment Descriptor is XML file used by web container to define servlets match up with which URLs. It will also specify the landing page for the root of the application

javax.servlet ===> package that contains the interfaces and the classes required for implementing the Servlet

javax.servlet.http ===> package that contains interfaces and the class required to handle the HTTP request and response

Ways to Create a Servlet:
Create a normal java, and then:

1. implements Servlet interface: parent interface of any Servlet class

2. extends GenericServlet class: abstract class that implements the Servlet interface. Only one method is declared abstract in this class and that is service() method

3. extends HttpServlet class



So now, come back on FirstApp-->right click-->new--->normal java class


package com.itvedant;

class name-- FirstServlet

it will not contain main method.

package com.itvedant;

import javax.servlet.Servlet;

public class FirstServlet implements Servlet{
 
}

now we r getting error becoz Servlet is an interface, we need to override methods.
So, right click on the error and override all the methods.

package com.itvedant;

import java.io.IOException;

import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class FirstServlet implements Servlet{

	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ServletConfig getServletConfig() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getServletInfo() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void init(ServletConfig arg0) throws ServletException {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {
		// TODO Auto-generated method stub
		
	}
 
}

Now along with this we will understand lifecycle of servlet

------------------------------------------------
Life Cycle of the Servlet -- the compilation of the code is done by in-built jdk compiler only.
So this step creates .class file and then lifecycle starts-- i.e.


1. Load servlet class ===> load the class file of the servlet in the web container
2. Create Servlet class instance ===> Web container will create the instance/object of the servlet class, only one object of the servlet will be created
3. Call init() method ===> web container will call the init() method defined in the servlet class, this method is called only once.
4. Call service() method ===> web container will call the service() method only when someone requests for the servlet. This method will be called for every request on the servlet. This method will contain the code for the response generation.
5. Call destroy() method ===> web container will call destroy() method when the instance/object of the servlet class is destroyed.

So when we override Servlet method, in the above code , 3 methods got overridden, init , service and destroy method.


package com.itvedant;

import java.io.IOException;

import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class FirstServlet implements Servlet{

	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		System.out.println("Destroy() method called");
		
	}

	@Override
	public ServletConfig getServletConfig() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getServletInfo() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void init(ServletConfig arg0) throws ServletException {
		// TODO Auto-generated method stub
		System.out.println("Init() Method called");
		
	}

	@Override
	public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Service() method called");
		
	}
 
}


now if we want our servlet to be executed-- in order to map the req to the servlet,
we need to map the Servlet Class with some url using--
1. web.xml
2. annotation 

i.e.
In order to request the Servlet we need to map the Servlet class with the some URL using:

1. web.xml

2. annotation

So in web.xml file, we will add some codes--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>FirstApp</display-name>
  <welcome-file-list>
    <welcome-file>home.html</welcome-file>
  </welcome-file-list>
  <servlet>
	<servlet-name>First</servlet-name>  -------------------------- this name is not restricted to servlet name. It can be anything
	<servlet-class>com.itvedant.FirstServlet</servlet-class> ------ this is restircted. It can be exact path only.
  </servlet>
  <servlet-mapping>
	<servlet-name>First</servlet-name>
	<url-pattern>/first</url-pattern>
  </servlet-mapping>
</web-app>

now right click on firstapp, run as server--
in the output we will see init() called, service() called

http://localhost:8080/FirstApp/first

we will not get any output becoz we have not get 

now as many times will click our url, service() gets executed

Now goto server tab from prompt-- right click-- clean-- restart-- now when we clean our server destroy() gets called.

Now if u want an html response-- in FirstServlet.java

	
	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Service() method called");
		res.setContentType("text/html");
		PrintWriter out = res.getWriter();
		out.print("First Servlet");
		
	}
 
now http://localhost:8080/FirstApp/first -- o/p first servlet

out.print("<h3 style=color:green;> First Servlet</h3>");--- we can make following changes.

http://localhost:8080/FirstApp/first----- see the o/p. Internally it is creating this html page.



---
Now generic servlet class-- servlet interface is the parent interface of any servlet class.
Now when we r implementing servlet class it is forcing us to overwrite all the servlet methods. What if
i dont want to overwrite , then its not possible using only Servlet interface.

So we use GenericServlet class.

extends GenericServlet class: abstract class that implements the Servlet interface. 
Only one method is declared abstract in this class and that is service() method

So creating new java class under same pkg--

Now itis not going to implement my interface instead it is going to extend my GenericServlet class.

it forces u to override only service().

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.GenericServlet;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class SecondServlet extends GenericServlet{

	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		// TODO Auto-generated method stub
		res.setContentType("text/html");
		PrintWriter out = res.getWriter();
		out.print("<h4>Servlet using GenericServlet Class</h4>");
		}

}


now we will do url mapping--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>FirstApp</display-name>
  <welcome-file-list>
    <welcome-file>home.html</welcome-file>
  </welcome-file-list>
  <servlet>
	<servlet-name>First</servlet-name>
	<servlet-class>com.itvedant.FirstServlet</servlet-class>
  </servlet>
  <servlet-mapping>
	<servlet-name>First</servlet-name>
	<url-pattern>/first</url-pattern>
  </servlet-mapping>
  <servlet>
	<servlet-name>Second</servlet-name>
	<servlet-class>com.itvedant.SecondServlet</servlet-class>
  </servlet>
  <servlet-mapping>
	<servlet-name>Second</servlet-name>
	<url-pattern>/second</url-pattern>
  </servlet-mapping>
	
  
</web-app>

http://localhost:8080/FirstApp/second--

Now creating anchor tab for first and second in home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
</body>
</html>



----------------------------------------------

3. extends HttpServlet class: this class contains the method for handling each HTTP request separately 
eg. for post request it has doPost() method
for get request it has doGet() method
Ther are many diifer types of http servlet requests.http get, http post, delte, update reqs
Now all these methods are categorized by service(). There is no categorization.



HTTP Get and Post

HTTP GET

1. Length restriction ===> limited
2. Retrieve the data from the URL (header part of the URL)
3. Visible to everyone
4. Not secure
5. Can be bookmarked

HTTP POST

1. No restriction on the length
2. Retrieve the data from the request body
3. Since the data is part of request body, data is not visible to everyone
4. More secure and is encrepted
5. Cannot be bookmarked

So now in our home page, we will create 1 form-- home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
	<form action="first" method="get">
	Name:
	<input type="text" name="name"/>
	<input type="submit" value="OK"/>
	
	
	</form>
</body>
</html>

and firstServlet.html

only change in service() rest all same--

	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Service() method called");
		res.setContentType("text/html");
		PrintWriter out = res.getWriter();
		out.print("<h3 style=color:green;> First Servlet</h3>");
		out.print("<h4>Servlet using Servlet Interface</h4>");
		
	}

run as server--

If i will put name and click ok-- req is going to 1st servlet.

now if we will change our url in home.html to second then it will goto our second servlet.


<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
	<form action="second" method="get"> ---------------- change this to second
	Name:
	<input type="text" name="name"/>
	<input type="submit" value="OK"/>
	
	
	</form>
</body>
</html>

refresh url-- and put name.

now irrespective of <form action="second" method="get"> get or post same method will be called.

in the get we will see data going through url but in post we will not.

But many a times we will have a scenario where for get req we want to do some task, for post some.
Currently service() is only handling.

So we have a 3rd type of servlet-- the http servlet class contains a method for handling each type
of servlet req. 

so we have extends HttpServlet class: this class contains the method for handling each HTTP request separately 
eg. for post request it has doPost() method
for get request it has doGet() method

so here 1st the req will come to service method only but then req will be transffered based on the req to 
diff methods.

So create new servlet class ThirdServlet


1st doget()-- it gets 2 parameters.

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ThirdServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			out.print("<h4> Servlet using Http Servlet Class </h4>");
			out.print("<h5>Get Method</h5>");
		
		
		
	}

}




now we r going map in web.xml --

 <servlet>
	<servlet-name>Third</servlet-name>
	<servlet-class>com.itvedant.ThirdServlet</servlet-class>
  </servlet>
  <servlet-mapping>
	<servlet-name>Third</servlet-name>
	<url-pattern>/third</url-pattern>
  </servlet-mapping>

--
now in home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
	<form action="third" method="get"> ---------------------
	Name:
	<input type="text" name="name"/>
	<input type="submit" value="OK"/>
	
	
	</form>
</body>
</html>

--

what if it changes to post method--

lets say if in home.html we change it to post(), then the req will goto service() and after that it will give error

So if i want to handle post method also, then-- add in ThirdServlet.java


	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			out.print("<h4> Servlet using Http Servlet Class </h4>");
			out.print("<h5>Post Method</h5>");
		
		
		
	}

refresh browser and see.

--

Servlet part 2--

Servlte is a normal java class and to make a java class
act like a servlet class we need to either implement
an interface called servlet interface which has methods like init, destroy service.
There are 2 more methods which are part of this but most imp are these 3 only.
Service method handles any type of the request,
that will be coming from the client. 
so when the req reach the server, the server handover this req to web container,
the web container is going to call the service().

The no. of instance of 1 servelet class that can exist at 1 time is only 1.
So, even if it is 100 req , all these req will be, handled by a single
servlet instance.

So the .java file is created, which is compiled
as a .class file, this will be handed over to web
container, where the life cycle of the servlet class
is controlled by the web container.
---

So now we will restructure home.html nicely--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
<style>
	td{
	 padding:10px;
	}

</style>
</head>
<body>
		<form action="third" method="get">
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" name="name"/></td>
			</tr>
			<tr>
				<td>Marks:</td>
				<td><input type="number" name="marks"/></td>
			</tr>
			<tr>
				<td>Color:</td>
				<td>
					<select name="color">
						<option value="none">.....</option>
						<option>Red</option>
						<option>Blue</option>
						<option>Green</option>
						<option>Pink</option>
						<option>Purple</option>
						<option>Grey</option>
						<option>Violet</option>
						<option>Indigo</option>
					</select>
				</td>
			</tr>
			<tr>
				<td><input type="submit" value="OK"/></td>
				<td><input type="reset"/></td>
			</tr>
		</table>
	</form>
</body>
</html>

now run app-- go to browser-- submit some values-- all the values are going in the url--
sO THE DATA Is going in the form of a key value pair.
So whatever we r sending in the url is going in the form of a req.
i.e. the name of the field will remain same. But the value will vary.

So next we will read tis value and present that value.

So next what we r going to do is in the dopost method we will call doGet().

So we will sent content response text as html.
and we will generate the response by creating the out object . These 2 steps we have alredy done.

So now in ThirdServlet.java--


package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ThirdServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			String name = req.getParameter("name");
			String marks = req.getParameter("marks");
			String color = req.getParameter("color");
		
			out.print("Hello, "+name);
			out.print("<br/>You have scored : "+marks);
		
	}
	
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		doGet(req,resp);
		
		
		
	}
}


run--- put values in browser


Now lets say I want to present this entire output as some color in the browser,
So whatever color is selected, 

so make following changes--

			out.print("<p style='color:" + color + "';>");			
			out.print("Hello, "+name);
			out.print("<br/>You have scored : "+marks);			
			out.print("</p>");
		
Now lets say we want to do some calc on this amrks value,
lets suppose we want to divide marks by 500 to calc what is the aggregate.
For this marks value has to be in proper foramt first and not in String type.

getParameter() returns value in Stirng form.We will do typecasting. thirdservlet.java


	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			String name = req.getParameter("name");
			float marks = Float.parseFloat(req.getParameter("marks"));
			String color = req.getParameter("color");
			float aggregate = (marks/500)*100;
			
			out.print("<p style='color:" + color + "';>");			
			out.print("Hello, "+name);
			out.print("<br/>You have scored : "+aggregate + "%");			
			out.print("</p>");
		
	}


--

Now lets say I don't want to send empty string or missing value.
And if value is not sent the eroor msg should come

So we will not create complete form by using html page, instead by HttpServlet.

We can setup our servlet as homepage.

So we will create a new servlet--  So now we will see validation part.

new-->dynamic web project-->project name-->ValidationApp

now, right click validation app->new ->java class->package-- com.itvedant , file name-- HomeServlet

package com.itvedant;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HomeServlet extends HttpServlet{
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO Auto-generated method stub
		super.doGet(req, resp);
	}
	
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(req, resp);
	}
}


this is waht we have done till now.

Now, if the req is coming directly to HomeServlet, so we will need to set url.
For that we will need web.xml file.

Now right click on project folder-->java ee tools-->generate deployment descriptor stub--
so now in src->web-inf folder, web.xml file is ready.

Here, welcome file list,we will map srvlet

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>ValidationApp</display-name>
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>
  <servlet>
	<servlet-name>Home</servlet-name>
	<servlet-class>com.itvedant.HomeServlet</servlet-class>	
  </servlet>
  <servlet-mapping>
	<servlet-name>Home</servlet-name>
	<url-pattern>/home</url-pattern>
  </servlet-mapping>
</web-app>

now 1st time when we will run , it will give me error, because we have not created those files yet.

Now lets say in HOmeServlet under, doGet() we have written--

public class HomeServlet extends HttpServlet{
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = resp.getWriter();
		resp.setContentType("text/html");
		out.println("Welcome");
}

run as-- http://localhost:8080/ValidationApp/home

Now if you want directly the req should go to home page only,
so, in web.xml file--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>ValidationApp</display-name>
  
  <servlet>
	<servlet-name>Home</servlet-name>
	<servlet-class>com.itvedant.HomeServlet</servlet-class>	
  </servlet>
  <servlet-mapping>
	<servlet-name>Home</servlet-name>
	<url-pattern>/home</url-pattern>
  </servlet-mapping>
  <welcome-file-list>
    <welcome-file>home</welcome-file>
    
  </welcome-file-list>
</web-app>


So now our req is going directly to home servlet.
Now copy form from home.html to HomeServlet.java bcoz we want to create form.
So make the changes in HomeServlet.java

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HomeServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		PrintWriter out = resp.getWriter();
		resp.setContentType("text/html");
		
		out.print("<form action='validate' method='get'>");
		out.print("<table><tr><td>Name:</td>");
		out.print("<td><input type='text' name='name'/></td>");
		out.print("</tr><tr><td>Marks:</td>");
		out.print("<td><input type='number' name='marks'/></td>");
		out.print("</tr><tr><td>Color:</td><td>");
		out.print("<select name='color'>");
		out.print("<option value='none'>.....</option>");
		out.print("<option>Red</option>");
		out.print("<option>Blue</option>");
		out.print("<option>Green</option>");
		out.print("<option>Pink</option>");
		out.print("<option>Purple</option>");
		out.print("<option>Grey</option>");
		out.print("<option>Violet</option>");
		out.print("<option>Indigo</option>");
		out.print("</select></td></tr><tr>");
		out.print("<td><input type='submit' value='OK'/></td>");
		out.print("<td><input type='reset'/></td></tr></table></form>");
	}
	
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		doGet(req, resp);
	}
}


now,creatting into servlet is not an easy task, so we will be using jsp--

Now, we directly have an option of creating servlet.
The adv here is we donot have to create java file then servlet.

So, right click project->new->servlet-->package-- com.itvedant-->class name-->ValidateServlet

so name of my servlet will be automatically set to ValidateServlet

-->next-->now name u can change to Validate-->now in url mapping bcoz V in validate is capital,
so, click Validate in url mapping-->edit make it validate.-->ok-->next-->click the methods u want-->finish

now, keep these functions remove others, if u want to keep that is also fine.

@WebServlet(name = "Validate", urlPatterns = { "/validate" })-- in this line we mapped 
the servlet class with the url,so that the web container can send the request to the requested servlet.
For this 1 way is web.xml file. Here create a deployment descriptor file and do the url mapping.
2nd way --annotation-- @WebServlet above the servlet class. Here u donot need to write anything in web.xml file.

http://localhost:8080/ValidationApp/validate

Now changing the doGet() to see if its actually coming here,

Now we will try to validate data, that our name field is not empty,

ValidateServlet.java

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ValidateServlet
 */
@WebServlet(name = "Validate", urlPatterns = { "/validate" })
public class ValidateServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = response.getWriter();
		response.setContentType("text/html");
		
		String name = request.getParameter("name");
		if(name.equals("")) {
			out.print("<br/>Name not provided");
		}
		String marks = request.getParameter("marks");
		if(marks.equals("")) {
			out.print("<br/>Marks not provided");
		}
		String colo = request.getParameter("color");
		if(colo.equals("none")) {
			out.print("<br/>Color not selected");
		}
		
		out.print("<br/>Validate Servlet Reached");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


run as-- http://localhost:8080/ValidationApp/

donot give any value and see error.

Now we want error msgs come back to index page only. and not on other page.

so we will create a list--

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ValidateServlet
 */
@WebServlet(name = "Validate", urlPatterns = { "/validate" })
public class ValidateServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = response.getWriter();
		response.setContentType("text/html");
		List<String> errorList = new ArrayList<String>();
		String name = request.getParameter("name");
		if(name.equals("")) {
			errorList.add("Name not provided");
			
		}
		String marks = request.getParameter("marks");
		if(marks.equals("")) {
			errorList.add("Marks not provided");
		}
		String colo = request.getParameter("color");
		if(colo.equals("none")) {
			errorList.add("Color not provided");
		}
		if(errorList.isEmpty()) {
			request.getRequestDispatcher("success").forward(request, response);
		}
		else {
			
		}
		
		out.print("<br/>Validate Servlet Reached");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}



now lets say my data is fine and their is no error, then,
but in case of error we will do 2 types of operations using an interface called req dispatcher.

1st task-- req is given to servlet1, which gives name,marks and color.
Now, we will forward all the req to servelet2. The res that we will finally get,
we will get from servlet2.

Now lets give this task name as success servlet.

new->servlet-->java package-->com.itvedant-->Class name-->SuccessServlet-->next-->Sucess-->/success-->finish

now, from home servlet, we r bringing 3 things to validate servlet.

now if no error is there then in ValidateServlet.java errorlist is empty.
and we will forward our req to SuccessServlet.

if(errorList.isEmpty()) {
			request.getRequestDispatcher("success").forward(request, response); // fwd my req to success servlet
		}

SuccessServlet.java--

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		out.print("Success");
	}

run--> fill all the values-->success

Now on success page we want to fill all the details.

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(name = "Success", urlPatterns = { "/success" })
public class SuccessServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
  
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		//out.print("Success");
		String name = request.getParameter("name");
		String marks = request.getParameter("marks");
		String color = request.getParameter("color");
		
		out.print("<p style='color : " + color + ";'>");
		out.print("Welcome , "+name);
		out.print("<br/><br/> You have scored "+ marks);
		out.print("</p>");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


run as-- fill all the values-->ok. So here we forwarded our req from 1 servlet to another.

Now if u want to show aggregaate then on validate page only, u can also calc the aggregate and forward it to succes page.

So, ValidateServlet.java

	if(errorList.isEmpty()) {
			float m = Float.parseFloat(marks);
			// now this aggregate and m are local variable. We need to forward this local variable to
			// another servlet
			float aggregate = (m/500)*100;
			request.getRequestDispatcher("success").forward(request, response);
		}

now to forward req from servlet1 to 2, we r using forward().
We can also add our local variable in our RequestDispatcher only.

}
		if(errorList.isEmpty()) {
			float m = Float.parseFloat(marks);
			// now this aggregate and m are local variable. We need to forward this local variable to
			// another servlet
			float aggregate = (m/500)*100;
			
			// adding local variable in request.
			request.setAttribute("aggr", aggregate);------------------------------ aggregate will be identified as aggr in another servlet.
			request.getRequestDispatcher("success").forward(request, response);
		}


So going into successservlet--

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(name = "Success", urlPatterns = { "/success" })
public class SuccessServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
  
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		//out.print("Success");
		String name = request.getParameter("name");
		String marks = request.getParameter("marks");
		String color = request.getParameter("color");
		float aggregate = (float)request.getAttribute("aggr"); //----------------------
		
		out.print("<p style='color : " + color + ";'>");
		out.print("Welcome , "+name);
		out.print("<br/><br/> You have scored "+ marks);
		out.print("<br/><br/> Your aggregate is "+ aggregate + "%"); //--------------------
		out.print("</p>");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}

So what we did is-- 1st we r going to home servlet-->then to validate servlet where we r reading each req
, if there is no error and all the values are provided---> then to success servlet

Here the browser is not aware about this transition. This entire process is happening within server.
For browser, when we give all the input, input is going to validate.
But internally it is getting forwarded from validate to success. 
U can see the url. URL is not getting updated with success


What if we want to make browser aware about thi that is--
if we want to move control from 1 servlet to another we can do using 3 techniques.

1. using forward() of RequestDispatcher
2. using include() of RequestDispatcher
3. sendRedirect of HttpRequest

1. forward() of RequestDispatcher

The request of the current servlet is dispatched to another servlet specified. This transition is happening inside the server, 
the client ie. hence browser is not aware about this transition and will not update the URL accordingly

2. include() of RequestDispatcher

The response of the another servlet in included within the first servlet request. Here the final response is generated by the first servlet

3. sendRedirect of HttpServletResponse

The control will move from one servlet to another servlet specified.
 Here the transition will not happen within the server instead the client will issue a new request for the second servlet, 
hence the client is aware about the transition and will update the URL accordingly. 
But here the request of the first servlet is not send to the second servlet.

So lets say in case of error in validateservlet.java, i want my req to send back to home page,

so, ValidateServlet.java

	else {
			response.sendRedirect("home");
		}
		
So, now run-- just click ok, dont put any value. -- It is not going at validate page.

So to just distinguish, 
	else {
			response.sendRedirect("home?redirect=yes");
		}

just to understand that it is getting redirected.

run-- in case of error-- see the url.
so, in sendRedirect, url is aware. So its like a fresh req to another servlet.
So if u just want to do movement from 1 page to another use sendRedirect
and if u want to pass data the use forward().

Now lets say i want to goto my home page but I want to tell user about these errors.
i.e. i want to print my error list.
So next we will see include()---
for this i dont want to pass req from 1 servlet to another instead i will include
home servlet response under validate servlet.
where, the home servlet response is the form page which we r getting.
So here the req is not coming in the picture instead resp is coming.

So, we r sending req to home page. Now if errors are there i am printing my errors.
and after printing errors, home page should be reconstructed,this we will do
by including home servlet within my validate servlet.
We will not rewrite entire home code. So in this case,
servlet2 is home page which is included as response to servlet1 which is validate page.

So the compbined response of servlet1 and servlet2 is given as final response. ValidateServlet.java

	else {
			//response.sendRedirect("home?redirect=yes");
			out.print("<ul style='color:red;'>");
			for(String err:errorList) {
				out.print("<li>" + err + "</li>");
			}
			out.print("</ul>");
		}

run as-- do not provide any value and see.
errors are there. Now below these errors , I want my home page form reconstructed below this .

	else {
			//response.sendRedirect("home?redirect=yes");
			out.print("<ul style='color:red;'>");
			for(String err:errorList) {
				out.print("<li>" + err + "</li>");
			}
			out.print("</ul>");
			request.getRequestDispatcher("home").include(request,response);
			
		}

Now, run as-->give error--->see o/p.

so, wit the help of include, we r including the response of 1 servlet into our servlet.

--

Now to perform initialization, we have 2 interfaces.

1. ServletConfig
2. ServletContext

1 is used for entire application level initialization while another is used for only application level initialization.
So if we nedd some paramenters to be initialized before my servlet gets executed, for that these 2 parameters are used.

See earlier when we created FirstApp-->java resources-->FirstServlet.java--- see init() is there.
init() is taking 1 parameter that is of type ServletConfig. For every servlet, there is going to be 1 instance created for
servletconfig and it will be used to initialize the vaues required to be initialized and it is not sharable.

ServletConfig

Is an interface whose instance is created by the web container for each servlet. For every servlet, 
only one ServletConfig instance is created and is passed as the parameter to the init() method

This object contains initail parameter passed by the web container to the Servlet during initialization

Scope of this instance is restricted to the Servlet for which it is defined.

So now come back to HomeServlet--- the list that we generated using out.print(),
this doesn't need to be generated manually.
instead the value of the colors , we will put into ServletConfig initialization so it will become more dynamic.

So in ur web.xml-- define this as ur initial parameter.

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>ValidationApp</display-name>
  
  <servlet>
	<servlet-name>Home</servlet-name>
	<servlet-class>com.itvedant.HomeServlet</servlet-class>	
	<init-param>
		<param-name>colors</param-name>
		<param-value>Red,Blue,Yellow,Green,Purple,Pink,Indigo,Violet,Grey,Cyan,Magenta,Orange</param-value>
	</init-param>
  
  </servlet>
  <servlet-mapping>
	<servlet-name>Home</servlet-name>
	<url-pattern>/home</url-pattern>
  </servlet-mapping>
  <welcome-file-list>
    <welcome-file>home</welcome-file>
    
  </welcome-file-list>
</web-app>

Now we will extract <param-value>Red,Blue,Yellow,Green,Purple,Pink,Indigo,Violet,Grey,Cyan,Magenta,Orange</param-value>---- this is a single string.

Now, we r setting this initial parametr for home servlet. So vlidate and sucess servlet will not be able to acecess it.

So from homeservlet we r removing out.print red to indigo.

So the value we r setting in our initial parameter, we will be reading that first.

String colors = getInitParameter("colors");

since,in web.xml, we have setted it to colors.
so, colors has the entire list of param-value.

u can even print and check.

run as-- the entire color list is visible. But this we want in our drop off box.

So what we can do is we can seperate this list and create a string array.

		String colors = getInitParameter("colors");
		//out.print(colors);
		
		String[] colorVaues = colors.split(",");/----------------------------
		
		out.print("<form action='validate' method='get'>"); 

and print using for loop. So --


public class HomeServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		PrintWriter out = resp.getWriter();
		resp.setContentType("text/html");
		
		String colors = getInitParameter("colors");
		//out.print(colors);
		
		String[] colorValues = colors.split(",");
		
		out.print("<form action='validate' method='get'>");
		out.print("<table><tr><td>Name:</td>");
		out.print("<td><input type='text' name='name'/></td>");
		out.print("</tr><tr><td>Marks:</td>");
		out.print("<td><input type='number' name='marks'/></td>");
		out.print("</tr><tr><td>Color:</td><td>");
		out.print("<select name='color'>");
		out.print("<option value='none'>.....</option>");
		
		
		for(String c : colorValues) {
			out.print("<option>"+ c + "</option>");
		}
		
		out.print("</select></td></tr><tr>");
		out.print("<td><input type='submit' value='OK'/></td>");
		out.print("<td><input type='reset'/></td></tr></table></form>");
	}
	
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		doGet(req, resp);
	}
}

so on run as-- u will get drop down in colors.
give all the info--select color-- ok.
 But the thing is this is accessible only inside hoemservlet.

So now inside ValidateServlet--

and write something like this,
PrintWriter out = response.getWriter();
		response.setContentType("text/html");
		
		String colors = getInitParameter("colors");----------
		out.print(colors.charat(0));----------------------------------- doing some task-- it will give error.

		
		List<String> errorList = new ArrayList<String>();


we r getting NullPointException.

So remove above code from validateservlet.

So now we will talk about scope of data on servlet. ServletConfig has least scope and is accessible only inside single servlet.

Scope of the data in the servlet
1. ServletConfig: accessible only in the single servlet
2. HttpServletRequest: accessible in two servlets between which the request is transferred
3. HttpSession: 
4. ServletContext: accessible to the entire application means to all the Servlet & JSP of the application

ServletContext

Is an interface whose instance is created by the web container. Only one instance is created for the entire application (project). 
This instance is accessible to all the servlets and JSP of the project. 

We can initial the parameters in this object using web.xml or add the parameters in the servlet execution 

So inside web.xml, we will not put it inside any servlet, but directly after <display-name>

<display-name>ValidationApp</display-name>
  <context-param> ----------------------------------------------
	<param-name>developer</param-name>
	<param-value>Parinita</param-value>
  </context-param>
  
  <servlet> 

So now I want to access this value everywhere, like in home servlet,success servlet,validate servlet.

So, lets say in HomeServlet.java, we will just retrieve this value,--

out.print("</select></td></tr><tr>");
		out.print("<td><input type='submit' value='OK'/></td>");
		out.print("<td><input type='reset'/></td></tr></table></form>");
		
		String dev = getServletContext().getInitParameter("developer"); -----------
		out.print("<h6>&copy;" + dev + "</h6>"); ----------------------------------
	}
	
	@Override
	protected void doPost

run as-- url--see o/p

Now if u will try to access this code in other servlets also, then it will be accessible to u.
Lets say ValidateServlet.

}
		
		String dev = getServletContext().getInitParameter("developer");
		out.print("<h6>&copy;" + dev + "</h6>");
		
		
	}

	
	protected void doPost

then also u will not get any error.

infact in servlets also u can add values inside context parameters.

egHomeServlets, 1 st u will have reference

String dev = getServletContext().getInitParameter("developer");
		out.print("<h6>&copy;" + dev + "</h6>");
		
		ServletContext ctx = getServletContext();------------------------
		ctx.setAttribute("sample","sampling context");-------------------
	}

u will be able to access this into SuccessServlet,

		out.print("<br/><br/> Your aggregate is "+ aggregate + "%");
		out.print("</p>");
		

		ServletContext ctx = getServletContext();
		String samp = (String)ctx.getAttribute("sample");
		out.print(samp);
	}

this parameter we have set in home servlet, the servlet is going from home to validate
and then from validate to success servlet.

So there are 2 ways of defining servlet context. define it as an initial parametr,
in ur web.xml file or, in the servlet execution get the reference of the servletcontext,
and then set the attribute accordingly.

Servlet part 4---

Now starting with HttpSession object.
So for ur server to remember you, i.e. to recall data we will use HTTP Session.
And for that we need session mgmt.

Session Management Requirement is because HTTP is a stateless protocol wherein the server will not remember anything that 
the user send once the response has been sent back. Everytime user requests to the server, 
server will treat the request as a new request. So there is a need to maintain the state(information) 
of the user so that server can identify the request from the same user.

Session is time interval.

Session Management is the way to maintain the state of the user.

Session Management can be implemented using 4 techniques:
1. HttpSession Object
2. Cookies
3. Hidden Form Field
4. URL Rewriting


HttpSession Object

Is an interface used to manage session for each user. Web container will create the sesssionid for each user and 
will maintain the information related to the user using this sessionid

HttpSession can be created using:

1. HttpSession(): Return current session associated with this user or if there is no session, then will create a new session
2. HttpSession(boolean create):
			create -> true: Always create a new session
			create -> false: Return current session associated with this user or if the session object does not exists for the current user then it will return null


Now lets say our home page opens directly, but we want home page to open only if user is logged in and user id pwd is correct.
So we will create a new web page.
so validateapp---->right click---> new--->jsp page for login and pwd.

index.jsp---

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
	<form action="login" method="post">
		<table>
			<tr>
				<td>Username:</td>
				<td><input type="text" name="username" required></td>
			</tr>
			<tr>
				<td>Password:</td>
				<td><input type="password" name="password" required></td>
			</tr>
			<tr>
				<td><input type="submit" value="login"></td>
				<td><input type="reset"></td>
			</tr>
		</table>
	</form>

</body>
</html>

After this we will make changes in our web.xml file because we need to make index.jsp pages as our home page.

So, web.xml--

	<url-pattern>/home</url-pattern>
  </servlet-mapping>
  <welcome-file-list>
    <welcome-file>index.jsp</welcome-file>-------------------------------
    
  </welcome-file-list>
</web-app>

run as-- run on server-- now if u will put username and password-- url will be directed to login servlet.

So will create 1 servlet file now.

new-- servlet file--> package name-->com.itvedant-->class name LoginServlet-->next-->name-->Login-->url /login-->ok-->finish

Now from url, req is coming as a post req, and not a get req.
So if we want we can remove this get req.


package com.itvedant;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet(name = "Login", urlPatterns = { "/login" })
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
   
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
	}

}


considering a case where username and pwd are matching--



package com.itvedant;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet(name = "Login", urlPatterns = { "/login" })
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
   
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String username = request.getParameter("username");
		String password = request.getParameter("password");
		
		if(username.equals(password)) {
			request.getRequestDispatcher("home").forward(request, response);
		}
		else {
			
		}
	}

}

if they donot match then i can fwd the req to another page. and logic we will write in else part.
and for that we will create a new servlet.

new--servlet--->ErrorServlet--->next--->Error-->/error--->finish

Now in this servlet the req will be coming if there is an error.

So in LoginServlet.java


		if(username.equals(password)) {
			request.getRequestDispatcher("home").forward(request, response);
		}
		else {
			response.sendRedirect("error");
		}
	}

}

ErrorServlet.java-----------------------------------------
package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ErrorServlet
 */
@WebServlet(name = "Error", urlPatterns = { "/error" })
public class ErrorServlet extends HttpServlet {
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		out.println("<h1 style='color:red;'>Username or Password is wrong</h1>");
		
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}

run project--
abc 
abc
ok-- got home page

abc
def
ok--- password or username wrong . So we can say our navigation is proper.

Now lets just imagine that in our home page we have created some links,
i.e. if user abc is there then after login , it will print something like welcome abc
and the form page will come. So on hoemservlet---

		String colors = getInitParameter("colors");
		//out.print(colors);
		
		String[] colorValues = colors.split(",");
		String username = req.getParameter("username");----------------
		
		out.print("<h4>Welcome, "+username +"</h4>");------------------
		
		out.print("<form action='validate' method='get'>");
		out.print("<table><tr><td>Name:</td>");
		out.print("<td><input type='text' name='name'/></td>");


run as-- abc abc--login--see the o/p

Now, on all pages I want my session to remember that the username is abc. So we will create 1 more servlet page--
So just some dummy servlet we r going to create.

new servlet--->com.itvedant--->AdmissionServlet--->next-->Admission--->/admission--->finish


 
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = response.getWriter();
		String username = request.getParameter("username");
		out.print("<h4>Welcome, "+username +"</h4>");
		}


Since, the req is originating from home servlet only. So after welcome in HomeServlet--

	
		out.print("<h4>Welcome, "+username +"</h4>");
		
		out.print("<a href = 'admission'>Admission</a>");------------------------------
		out.print("<form action='validate' method='get'>");

run-- index to login to admission page.So in login page it remembers username.
but in admission page it doesn,t remeber and we r getting welcome, null as o/p.
it has forgotten. So to remeber across diff pages in single session--

on the page from where req has been generated, while reading the username in homeservlet,
we will keep it in httpsession object. We have 2 methods. getSession with parameter and without parameter.
Without parameter one returns current session object and if no session object is created yet , then it creates 
the session object.

		String username = req.getParameter("username");
		HttpSession session = req.getSession(); ------------- here no session object  exist so it will create a new session object.
		
		out.print("<h4>Welcome, "+username +"</h4>");
		
Now this session will be created if the login is sucessful. So after login page, the page
in which we r going, there we can start with our session object.U can put the values in ur session object.

		String username = req.getParameter("username");
		HttpSession session = req.getSession();
		session.setAttribute("uname", username);------------------
		
		out.print("<h4>Welcome, "+username +"</h4>");

Now after login we will goto index where it remebers after that we will goto admission where it doesnt remember.
So, in admissionservelt, we will not create a new sesson object, instead the already existing object will be used.

HttpSession sess = request.getSession();

and then we will extract the value.

we will not read it like this String username = request.getParameter("username"); because data is not coming through request.
because we have not forwarded anything from home page. We have just created a hyperlink, when we will clcik on that 
hyperlink,then req is coming here, So we will read the values. 

		PrintWriter out = response.getWriter();
		//String username = request.getParameter("username");
		
		HttpSession sess = request.getSession();
		String username = (String)sess.getAttribute("uname");-------------
		out.print("<h4>Welcome, "+ username +"</h4>");
		}

run---now it remembers.

So what is happening is--In the session mgmt, after the successful login, u r creating a session object.
Session id will be created in the memory. Whatever information u will set using set attribute,
that will be added in that memory location till the time session object is active.
So lets say if we create logout 

		out.print("<h4>Welcome, "+username +"</h4>");
		
		out.print("<a href = 'admission'>Admission</a>");
		
		out.print("<a href='logout'>Logout</a>:");
		out.print("<form action='validate' method='get'>");

so now we will create a logout servlet,

new-->servlet-->com.itvedant-->LogoutServlet--> /logout

package com.itvedant;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;


@WebServlet(name = "Logout", urlPatterns = { "/logout" })
public class LogoutServlet extends HttpServlet {
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		HttpSession sess = request.getSession();
		sess.invalidate();
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


run as--->login-->admission-->logout-->admission 
i.e. session object is destroyed.

for the same user, same session id is created until and unless we destroy the session object.
Now how it remebers, the session ids of the user, is by using cookies in the m/c. Cookies maintain session id.

so in browser-->settings--->local host

Now, these session ids are occupying space , but our server has limited amount of space, and for each req if session is created
alot of space will be req. So we will use another method-- where we will save nothing at server m/c but at clients m/c only.

but 1st getSession() with parameter. lets say i have not logged in and i am directly 
going into logout page using url http://localhost:8080/ValidationApp/logout

here i am not getting any error. This is bcoz of the getSession().
the HTTPSession object returns current session associated with this user or we can say--

HttpSession can be created using:

1. HttpSession(): Return current session associated with this user or if there is no session, then will create a new session.
So even if we directly logout, it will create a new session without throwing any error.
2. HttpSession(boolean create):
			create -> true: Always create a new session
			create -> false: Return current session associated with this user or if the session object does not exists for the current user then it will return null




in logoutservlet-->getSession() with parameter is something like-- do the changes 

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		HttpSession sess = request.getSession(false);----
		sess.invalidate();


run-- http://localhost:8080/ValidationApp/logout -->refresh-->u will get error-->etting null pointer exception 
bcause since login is not done, session is not existing.

---
now, we will store user's info in user's m/c only.
------------------------------------------------
Cookie

In case of the HttpSession we have seen that the sessionid is maintained using cookies. 
We can also the cookies to maintain more information so that the server is not maintaining the information related to each user instead it is maintained in client's machine itself.

Cookie is file stored in the client machine. This file is send along with the response from the server.
 Now everytime the request is send to the server, all the cookie related will be send along with request.

1. Cookies can be implemented using Cookie class and create the instance of this class
2. This cookie instance will be added in the response of the servlet using addCookie(Cookie) of the response object
3. All the cookies related to this server will be send from the client machine along with the request and then we can extract all the cookies 
from the request using getCookies() 

So we will create a new project now for showing how cookieworks.

so, file-->new---> dynamic web project-->proj name-->SessionManagementUsingCookies--->finish

SessionManagementUsingCookies-->new-->jsp-->index.jsp-->finish

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
	<a href="login.jsp">Login</a><br/>
	<a href="profile">Profile</a><br/>
	<a href="logout">Logout</a><br>

</body>
</html>

SessionManagementUsingCookies-->new-->jsp-->login.jsp-->finish

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
	<form action="login" method="post">
		<table>
			<tr>
				<td>Username:</td>
				<td><input type="text" name="username" required></td>
			</tr>
			<tr>
				<td>Password:</td>
				<td><input type="password" name="password" required></td>
			</tr>
			<tr>
				<td><input type="submit" value="login"></td>
				<td><input type="reset"></td>
			</tr>
		</table>
	</form>
	
</body>
</html>

new-->servlet-->com.itvedant--->LoginServlet--->Finish

change in url to /login in the code like--

in the doPost() we will read the content.

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/login")
public class LoginServlet extends HttpServlet {
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		response.getWriter().append("Served at: ").append(request.getContextPath());
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String username = request.getParameter("username"); // same name as given in login.jsp
		String password = request.getParameter("password");
		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		// if user id , pwd is not correct then,
		request.getRequestDispatcher("index.jsp").include(request, response);
		
		if(username.equals(password)) {
			out.print("Successfully logged in");
			Cookie c = new Cookie("username",username);
			response.addCookie(c);
		}
		else {
			out.print("Username or passsword is incorrect");
			request.getRequestDispatcher("login.jsp").include(request, response);
		}
	}

}


run as-->login-->same username pwd-->suucc logged in.

if username pwd is incorect, msg is getting printed.

so see in edge browser-- all cookies and site data-- search localhost under which u will see localhost.
this is giving info like when it was created when it will expire.

So lets say, next time, it is reading this cookie. that means all the cookies htat we have,
it wants to take with it and read it.

new-->servlet--->com.itvedant-->ProfileServlet--->finish

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/profile")
public class ProfileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		response.setContentType("text/html");
		PrintWriter out =  response.getWriter();
		
		
		request.getRequestDispatcher("index.jsp").include(request, response);
		
		Cookie[] ck = request.getCookies();
		
		if(ck!=null) {
			for(Cookie c : ck) { // 1st cookie is of session array. So for each cookie 
				if (c.getName().equals("username")){
					String name = c.getValue();
					out.print("Welcome, " + name );
				}
			}			
		}
		else {
			out.print("Please login first");
			request.getRequestDispatcher("login.jsp").include(request, response);
		}
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


run-- now when it is saying welcome, abc -- this info is not getting stored in ur server,
but on the clients m/c or localhost in the form of a cookie. So when the req will go to 
thwe same m/c using this cookie it will identify.

If u want to delete or want to logout u can set age to ur cookie.U can set it to 0.

So new->servlet->LogoutServlet->finish

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/logout")
public class LogoutServlet extends HttpServlet {
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		request.getRequestDispatcher("index.jsp").include(request, response);
		Cookie c = new Cookie("username", "");
		c.setMaxAge(0);
		response.addCookie(c);
		out.print("Successfully logged out");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}

run-->

so we r using cookies to maintain our sessions.

We can maintain sessions using hidden fields, and from urls which will be discussed later.


------------------------------------------------------------
JSP(Java Servlet Pages)

Cookie

In case of the HttpSession we have seen that the sessionid is maintained using cookies. We can also the cookies to maintain more information so that the server is not maintaining the information related to each user instead it is maintained in client's machine itself.

Cookie is file stored in the client machine. This file is send along with the response from the server. Now everytime the request is send to the server, all the cookie related will be send along with request.

1. Cookies can be implemented using Cookie class and create the instance of this class
2. This cookie instance will be added in the response of the servlet using addCookie(Cookie) of the response object
3. All the cookies related to this server will be send from the client machine along with the request and then we can extract all the cookies from the request using getCookies() 

------------------------------------------------------------
JSP(Java Servlet Pages)--
JSP came after servlets were created.
1 of the major drawback is the html part which u have to put inside double quotes. tags within it. They are quite difficult to analyze.
So instead of putting html code into java code, we can do a reverse thing,
that is,java code within html code.

So till now what we were doing was in servlet the response is generated using the object of the PrintWriter class, 
where the HTML code is written within the double quotes as a string. 
As the response is in the string format, find the problem is very difficult and even writing HTML code in java
 is a tedious job. A programmer must have the good knowlegde of java then only he can create servlet.

JSP page is the combination of the HTML and java code. We will create .jsp file with the base of HTML and Java code added for the business logic

Difference Between Servlet and JSP

Servlet
1. Java Code
2. Writing the code is harder as here HTML code is written with java functions.
3. For every request service() is called, hence we have to override service() method.
4. Mostly used for business logic/controller (move from one page to another)
5. Implementation is faster
6. Every time we make any changes in the servlet, the file is recompiled and the new class file is deployed in the server.

JSP
1. HTML based Code
2. Writing the code is easier as here java code is written with HTML tags when required.
3. For every request _jspService() is called , hence we have to override _jspService() method
4. Mostly used for presentation (final response)
5. Implementation is comparatively slower because here first JSP is converted into servlet
6. Every time we make the changes in the JSP file, they are updated in the server
-------------------------------------------------------
JSP Life Cycle 

1. Create JSP file (.jsp)

Translation Stage/Phase
2. JSP file is converted into Servlet file (.java)
		
		.jsp -----> .java

Compilation Stage/Phase
3. Servlet file is converted into class file (.class)
		.java -----> .class

Execution Phase
4. Load the class file in the web container
5. Web container will create the instance of this servlet class file. Only one instance 
6. Web container will call the init() method only once for this instance
7. Web container will call _jspService() method for every request
8. Web container will call the destroy() method when the instance is removed from the server.

----------------------------------------------------

create a new project-- file--new--dynamic web project-->JSPDemo-->finish

now we will add a jsp page--index.jsp-->finish

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h1>Welcome to JSP</h1>
</body>
</html>

now the translation of this file is going into my server.

D:\learning\apache-tomcat-9.0.87\work\Catalina\localhost\JSPDemo\org\apache\jsp

see the.java file. u will find diff methods.
most imp method is _jspService().the entire html page is written within out.print().
u can even see Welcome to JSp. Everything written inside out.print() is the
response that we have generated.
This file is generated by ur tomcat server. It is extending HttpjspBase.
it also contains init().

Now what we want to do is add java code within jsp page. So,

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h1>Welcome to JSP</h1>
	<form action="add.jsp">
		<table>
			<tr>
				<td>Number1</td>
				<td><input type="number" name="num1"/></td>
			</tr>	
			<tr>
				<td>Number2</td>
				<td><input type="number" name="num2"/></td>
			</tr>
			<tr>
				<td><input type="submit" value="add"/></td>
				<td><input type="reset"/></td>
			</tr>	
		</table>
	</form>
</body>
</html>

run as-->just make the changes-->save it--refresh it-->no need to deploy again and again. But in case of servlet u do.

lets say we want to send our req to another jsp page, i.e. add.jsp--so that when we give the nos. they will be forwarded to 
add.jsp.

So in add.jsp we will add java code. new-->jsp file-->add.jsp-->finish.

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>ADD</title>
</head>
<body>
<%
String num1 = request.getParameter("num1");
String num2 = request.getParameter("num2");

out.print("Sum = "+(num1+num2));
%>

</body>
</html>

now the problem over here is, the value coming in a url is a string value.
getParameter() always gives string value
So we will do typecasting.

<body>
<%
int num1 = Integer.parseInt(request.getParameter("num1"));
int num2 = Integer.parseInt(request.getParameter("num2"));

out.print("Sum = "+(num1+num2));
%>

</body>

save-->refresh browser-- from jsp to .java to .javac everything is in control of tomcat.
compilation part is not done by compiler in case of servlet.infact for add also u will get code in work folder.
And whatever code we have added in scriptlet, its part of my _jspService() now.

**************************************

jsp part 1 -- 2.webm 10:11





****************************************

Java Code can be written within the JSP page using scripting elements

Three types of the scripting elements:
1. Scriptlet Tag

Any java code can be written within JSP page. This code will be added in _jspService() method when translated

Syntax:
<% java code %>

2. Expression Tag

The code placed inside the expression tag is written to the output stream of the response. So you need not write, out.write() / out.print(). Its mostly used to print the value of the variable or the value returned by the method. This tag code is also added in _jspService() method

SyntaxL
<%= statement%>

3. Declarative Tag

Used to declare the variables and methods. The code written inside the declarative tag is placed outside _jspService() method, directly inside the generated class

Syntax:
<%! variable or method declaration %>

--------------------------------------------------------------
Comments in JSP

1. HTML Comments

Syntax:
<!-- Comment -->

This comment will added in the translate code using out.write() method inside _jspService() method. Only this comment will be part of the final response being send to the browser

2. JSP Comments

Syntax:
<%-- Comment --%>

This comment is not translated into the servlet file. This comment exists only in the JSP, and not in .java file

3. Java Comments

This comment will be placed directly inside the _jspService() method after translation. This comment is not added in the final response.

------------------------------------------------------
Directive Tags

Used to tell the web container how to translate the JSP page into the corresponding servlet

Syntax:
<%@ directive attribute="value" ..... %>

In directive we can specify page or include
Each directive has multiple predefined attributes to which we need to assign the values

-----------------------------------------------------
JSP Page Directive

Define some attributes that will define the translation if the entire page

<%@page ..... %>

language ===> programming language used to create the servlet, it has only one value, ie. java

contentType ===> define the type of the response generated by the page. For html response we use the value "text/html"

pageEncoding ===> define the encoding techinque using the response will be encoded

encode ===> decode (browser)

import ===> define the classes or interfaces or the entire package been used in jsp

session ===> define whether the page should include the session object. The default value is true. This attribute makes sure that each JSP page is the part of the session. But if we don't want some pages to be part of the session we can set the value of this attribute as false.

-----------------------------------------------------
JSP include directive

Used to include the content of any resource (JSP, HTML, Text) at the page translation phase. It can used to include the common layout file. It can be used to include only static page and not the page which will be changed at the runtime

<%@include file=""%>

------------------------------------------------------
Action Elements

Special Tag of the jsp to perform some specific task and is used to replace the java code with tags

jsp:forward
jsp:include

----------------------------------------------------

1. include directive will include the resource at the translation time, hence the entire code of the resource included is added in the response of the current page
2. include action tag will include the resource at the runtime, hence we can make some changes at the runtime in the response to be included.



jsp part 1 2.webm







 








 