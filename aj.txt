Web siters were static files,html pages, grphics and various other files.
A web app it is dynamic.
When a web appl prog runs on a server, it might not be containing proper html page.
that page might be a java apli, it might be a python appli,
So these applications are executed in the server and in the response,
these pages are going to generate your html page,
and this html page will be sent back to ur client.

Ur client, that is ur browser in response,
is always going to get an html page only.

Sometimes, when we r sending a req from client to server, we
might also send some data, so server will also read the data 
and tries to figure out reponse based on given data.

In web applications -- client sends a req,
req is handed to a web server.
Inside a web server there is an application which is always running.
the name of this appli  is web container.
This web container contains objects of all the servlets
that we are going to create which the user will be requesting.

That is the user req servelet, the servelet generates reponse,

Now every req that comes to a web container
is treated as a thread. So the amount of load coming on the processor reduces,
And its not going to create a thread because it has a thread pool,

Servlets--
it runs within web container. In our case it is,
Java Platform Enterprise Edition.
The web container implements Application Programming Interface.

Everything related to servelet is controlled by a web container.
i.e. creating objects of the servelet,calling method on the servelet,
giving back the response from the servelet,
everything is done by a web container.

So we as a programmer will only create a servelt.
We will not create new instance of servelet,
we will not call any method of the servelet,
So web container performs initial processing,
and selects the intended servelet to handle the req.
It controls the entire lifecycle of servelet.
browser send http request to ur web server,
web server gives it to web container,
Now based on the url, web container search for the
servelet that u r trying to req,
if it finds that servelt,
it tries to process that servelet,
handover the ersponse back, the response mostly will be html page.
which web container hands over to web server and which gives response to a client.



Based on the url,web con







requirement--
tomcat server installation -- donot install native one-- Tomcat 9.0.87 Released-- download-- binary distribution-- for core-- zip file-- extract-
-- start eclipse ide-- select workspace-- now first we need to add tomcat server and keep it ready--
so, windows-->show view-->servers--> close welcome window--->in the below part where output comes--> u can see servers
now click on the link no servers are available. Click this link to creATE new server--> in the dialog box click on apache server-->
--> the version that we r working is 9-->next-->
path where apache is installed, select that folder
i.e. D:\learning\apache-tomcat-9.0.87

now to start the server-- right click on Tomcat v9.0 Server at localhost[Stopped, Republish]-- start

server is active now, and within server web container is also active.

Now to test if we can reach our server , we will do little test--
now we r performing this activity on localhost only.
apache tomcat listens on server 8080--

So on the browser , write http://localhost:8080/

we r getting error page sent by apache tomcat.

error is ther becoz it doesnt know what to do on /.

now, going back to ide, double click on link--
and overview page will open related to server--

in that u have server location-- > click on use tomcat installation
--> press ctrl+s-- i.e. save it--> and restart server

now refresh http://localhost:8080/-- entire homepage is set.

now, creating 1st project-- file-->new-->dynamic web project-->
project name-- FirstApp-->finish

if u will expand this folder u will get required libraries.

for us the most important is firstapp->java resources-> src/main/java
All my servelet files will be inside it.
the same path we have in firstapp->src->main->java-- all the java files
will be part of this folder, all html files will be
part of webapp.

In order to run this application-->right click on FirstApp-->
-->run as server becoz i dont want to run this application
as standalone. I want to run it on the server.-->dialogue box-->
choose an existing server--see localhost written there--->tomcat v9.0-- started
-- click always use this server -->finish-->restart now-->ok

so we uploaded our entire project on server now.
see the url--

http://localhost:8080/FirstApp/


Now u can goto preferences--->u can even change browser-->
just search web browser--> use external web browser--> chrome
-->apply and close-->now run firstapp-> it will open on the chrome browser

Now we will design homepage--

homepage is page for url /

now see deployment descriptor firstapp-->
welcome pages-->
now the entire lifecycle of web server, we r not going to 
control it. So we need to provide some settings to my
web container that are related to application so that 
it knows what is to be done with this project.

for eg our home page if we r giving as /,
so which page is to be opened under which servlet,
that complete mapping we will be doing under
deployment descriptor, everything which data will go.

This deployment descriptor file is an xml file.
The name of this file is web.xml

Deployment Descriptor is XML file used by web container to define servlets match up with which URLs. It will also specify the landing page for the root of the application

Now to add the deployment descriptor file--
right click on first app-->java ee tools-->generate deployment descrptor stub--see under wen-inf folder

this is the xml file we need.

Now when u open this web.xml file-- below there are 2 tabs--
design and source

now right click web.xml-->open with generic text editor

Any 1 of the files present here can be your homepage.

So lets say index.html--
so how to add html file within ur project--

right click on project-->new html file--> Name it index.html

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
<h3>Welcome to first web application</h3>
</body>
</html>

save it and now run ur project

--
now lets say if I delete index.html file
right click on source to create new html file,
name it default.html

this is also my welcome file,

I can even create my own html welcome file.

from web.xml u can delete <welcome-file> part
and write--

home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
</body>
</html>


web.xml is like--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>FirstApp</display-name>
  <welcome-file-list>
    <welcome-file>home.html</welcome-file>
  </welcome-file-list>
</web-app>


now those who have installed eclipse java ee they donot need to do this otherwise-- search eclipse java ee on browser-- and install windowsx86

Tomserver is an application server.




Now in eclipse create a new workspace-- aj_try-- once it is launched u will see welcome msg with eclipse ide for enterprise java and web developers

---

now understanding http --

goto browser-->wikipedia india-->search-->right click inspect-->network-->name---> see request url--> request method is get-->
scroll down and see the response, accept (in accept it tells what all pages it can accept, so it can accept https)

now going to response-- the entire html page is sent back as response.

so while sending a request we follow a http protocol which we can see under headers, also remote addr-- addr of the m/c is going to server m/c



---

Deployment Descriptor is XML file used by web container to define servlets match up with which URLs. It will also specify the landing page for the root of the application

javax.servlet ===> package that contains the interfaces and the classes required for implementing the Servlet

javax.servlet.http ===> package that contains interfaces and the class required to handle the HTTP request and response

Ways to Create a Servlet:
Create a normal java, and then:

1. implements Servlet interface: parent interface of any Servlet class

2. extends GenericServlet class: abstract class that implements the Servlet interface. Only one method is declared abstract in this class and that is service() method

3. extends HttpServlet class



So now, come back on FirstApp-->right click-->new--->normal java class


package com.itvedant;

class name-- FirstServlet

it will not contain main method.

package com.itvedant;

import javax.servlet.Servlet;

public class FirstServlet implements Servlet{
 
}

now we r getting error becoz Servlet is an interface, we need to override methods.
So, right click on the error and override all the methods.

package com.itvedant;

import java.io.IOException;

import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class FirstServlet implements Servlet{

	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ServletConfig getServletConfig() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getServletInfo() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void init(ServletConfig arg0) throws ServletException {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {
		// TODO Auto-generated method stub
		
	}
 
}

Now along with this we will understand lifecycle of servlet

------------------------------------------------
Life Cycle of the Servlet -- the compilation of the code is done by in-built jdk compiler only.
So this step creates .class file and then lifecycle starts-- i.e.


1. Load servlet class ===> load the class file of the servlet in the web container
2. Create Servlet class instance ===> Web container will create the instance/object of the servlet class, only one object of the servlet will be created
3. Call init() method ===> web container will call the init() method defined in the servlet class, this method is called only once.
4. Call service() method ===> web container will call the service() method only when someone requests for the servlet. This method will be called for every request on the servlet. This method will contain the code for the response generation.
5. Call destroy() method ===> web container will call destroy() method when the instance/object of the servlet class is destroyed.

So when we override Servlet method, in the above code , 3 methods got overridden, init , service and destroy method.


package com.itvedant;

import java.io.IOException;

import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class FirstServlet implements Servlet{

	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		System.out.println("Destroy() method called");
		
	}

	@Override
	public ServletConfig getServletConfig() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getServletInfo() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void init(ServletConfig arg0) throws ServletException {
		// TODO Auto-generated method stub
		System.out.println("Init() Method called");
		
	}

	@Override
	public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Service() method called");
		
	}
 
}


now if we want our servlet to be executed-- in order to map the req to the servlet,
we need to map the Servlet Class with some url using--
1. web.xml
2. annotation 

i.e.
In order to request the Servlet we need to map the Servlet class with the some URL using:

1. web.xml

2. annotation

So in web.xml file, we will add some codes--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>FirstApp</display-name>
  <welcome-file-list>
    <welcome-file>home.html</welcome-file>
  </welcome-file-list>
  <servlet>
	<servlet-name>First</servlet-name>  -------------------------- this name is not restricted to servlet name. It can be anything
	<servlet-class>com.itvedant.FirstServlet</servlet-class> ------ this is restircted. It can be exact path only.
  </servlet>
  <servlet-mapping>
	<servlet-name>First</servlet-name>
	<url-pattern>/first</url-pattern>
  </servlet-mapping>
</web-app>

now right click on firstapp, run as server--
in the output we will see init() called, service() called

http://localhost:8080/FirstApp/first

we will not get any output becoz we have not get 

now as many times will click our url, service() gets executed

Now goto server tab from prompt-- right click-- clean-- restart-- now when we clean our server destroy() gets called.

Now if u want an html response-- in FirstServlet.java

	
	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Service() method called");
		res.setContentType("text/html");
		PrintWriter out = res.getWriter();
		out.print("First Servlet");
		
	}
 
now http://localhost:8080/FirstApp/first -- o/p first servlet

out.print("<h3 style=color:green;> First Servlet</h3>");--- we can make following changes.

http://localhost:8080/FirstApp/first----- see the o/p. Internally it is creating this html page.



---
Now generic servlet class-- servlet interface is the parent interface of any servlet class.
Now when we r implementing servlet class it is forcing us to overwrite all the servlet methods. What if
i dont want to overwrite , then its not possible using only Servlet interface.

So we use GenericServlet class.

extends GenericServlet class: abstract class that implements the Servlet interface. 
Only one method is declared abstract in this class and that is service() method

So creating new java class under same pkg--

Now itis not going to implement my interface instead it is going to extend my GenericServlet class.

it forces u to override only service().

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.GenericServlet;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class SecondServlet extends GenericServlet{

	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		// TODO Auto-generated method stub
		res.setContentType("text/html");
		PrintWriter out = res.getWriter();
		out.print("<h4>Servlet using GenericServlet Class</h4>");
		}

}


now we will do url mapping--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>FirstApp</display-name>
  <welcome-file-list>
    <welcome-file>home.html</welcome-file>
  </welcome-file-list>
  <servlet>
	<servlet-name>First</servlet-name>
	<servlet-class>com.itvedant.FirstServlet</servlet-class>
  </servlet>
  <servlet-mapping>
	<servlet-name>First</servlet-name>
	<url-pattern>/first</url-pattern>
  </servlet-mapping>
  <servlet>
	<servlet-name>Second</servlet-name>
	<servlet-class>com.itvedant.SecondServlet</servlet-class>
  </servlet>
  <servlet-mapping>
	<servlet-name>Second</servlet-name>
	<url-pattern>/second</url-pattern>
  </servlet-mapping>
	
  
</web-app>

http://localhost:8080/FirstApp/second--

Now creating anchor tab for first and second in home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
</body>
</html>



----------------------------------------------

3. extends HttpServlet class: this class contains the method for handling each HTTP request separately 
eg. for post request it has doPost() method
for get request it has doGet() method
Ther are many diifer types of http servlet requests.http get, http post, delte, update reqs
Now all these methods are categorized by service(). There is no categorization.



HTTP Get and Post

HTTP GET

1. Length restriction ===> limited
2. Retrieve the data from the URL (header part of the URL)
3. Visible to everyone
4. Not secure
5. Can be bookmarked

HTTP POST

1. No restriction on the length
2. Retrieve the data from the request body
3. Since the data is part of request body, data is not visible to everyone
4. More secure and is encrepted
5. Cannot be bookmarked

So now in our home page, we will create 1 form-- home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
	<form action="first" method="get">
	Name:
	<input type="text" name="name"/>
	<input type="submit" value="OK"/>
	
	
	</form>
</body>
</html>

and firstServlet.html

only change in service() rest all same--

	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Service() method called");
		res.setContentType("text/html");
		PrintWriter out = res.getWriter();
		out.print("<h3 style=color:green;> First Servlet</h3>");
		out.print("<h4>Servlet using Servlet Interface</h4>");
		
	}

run as server--

If i will put name and click ok-- req is going to 1st servlet.

now if we will change our url in home.html to second then it will goto our second servlet.


<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
	<form action="second" method="get"> ---------------- change this to second
	Name:
	<input type="text" name="name"/>
	<input type="submit" value="OK"/>
	
	
	</form>
</body>
</html>

refresh url-- and put name.

now irrespective of <form action="second" method="get"> get or post same method will be called.

in the get we will see data going through url but in post we will not.

But many a times we will have a scenario where for get req we want to do some task, for post some.
Currently service() is only handling.

So we have a 3rd type of servlet-- the http servlet class contains a method for handling each type
of servlet req. 

so we have extends HttpServlet class: this class contains the method for handling each HTTP request separately 
eg. for post request it has doPost() method
for get request it has doGet() method

so here 1st the req will come to service method only but then req will be transffered based on the req to 
diff methods.

So create new servlet class ThirdServlet


1st doget()-- it gets 2 parameters.

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ThirdServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			out.print("<h4> Servlet using Http Servlet Class </h4>");
			out.print("<h5>Get Method</h5>");
		
		
		
	}

}




now we r going map in web.xml --

 <servlet>
	<servlet-name>Third</servlet-name>
	<servlet-class>com.itvedant.ThirdServlet</servlet-class>
  </servlet>
  <servlet-mapping>
	<servlet-name>Third</servlet-name>
	<url-pattern>/third</url-pattern>
  </servlet-mapping>

--
now in home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
	<form action="third" method="get"> ---------------------
	Name:
	<input type="text" name="name"/>
	<input type="submit" value="OK"/>
	
	
	</form>
</body>
</html>

--

what if it changes to post method--

lets say if in home.html we change it to post(), then the req will goto service() and after that it will give error

So if i want to handle post method also, then-- add in ThirdServlet.java


	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			out.print("<h4> Servlet using Http Servlet Class </h4>");
			out.print("<h5>Post Method</h5>");
		
		
		
	}

refresh browser and see.

--

Servlet part 2--

Servlte is a normal java class and to make a java class
act like a servlet class we need to either implement
an interface called servlet interface which has methods like init, destroy service.
There are 2 more methods which are part of this but most imp are these 3 only.
Service method handles any type of the request,
that will be coming from the client. 
so when the req reach the server, the server handover this req to web container,
the web container is going to call the service().

The no. of instance of 1 servelet class that can exist at 1 time is only 1.
So, even if it is 100 req , all these req will be, handled by a single
servlet instance.

So the .java file is created, which is compiled
as a .class file, this will be handed over to web
container, where the life cycle of the servlet class
is controlled by the web container.
---

So now we will restructure home.html nicely--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
<style>
	td{
	 padding:10px;
	}

</style>
</head>
<body>
		<form action="third" method="get">
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" name="name"/></td>
			</tr>
			<tr>
				<td>Marks:</td>
				<td><input type="number" name="marks"/></td>
			</tr>
			<tr>
				<td>Color:</td>
				<td>
					<select name="color">
						<option value="none">.....</option>
						<option>Red</option>
						<option>Blue</option>
						<option>Green</option>
						<option>Pink</option>
						<option>Purple</option>
						<option>Grey</option>
						<option>Violet</option>
						<option>Indigo</option>
					</select>
				</td>
			</tr>
			<tr>
				<td><input type="submit" value="OK"/></td>
				<td><input type="reset"/></td>
			</tr>
		</table>
	</form>
</body>
</html>

now run app-- go to browser-- submit some values-- all the values are going in the url--
sO THE DATA Is going in the form of a key value pair.
So whatever we r sending in the url is going in the form of a req.
i.e. the name of the field will remain same. But the value will vary.

So next we will read tis value and present that value.

So next what we r going to do is in the dopost method we will call doGet().

So we will sent content response text as html.
and we will generate the response by creating the out object . These 2 steps we have alredy done.

So now in ThirdServlet.java--


package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ThirdServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			String name = req.getParameter("name");
			String marks = req.getParameter("marks");
			String color = req.getParameter("color");
		
			out.print("Hello, "+name);
			out.print("<br/>You have scored : "+marks);
		
	}
	
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		doGet(req,resp);
		
		
		
	}
}


run--- put values in browser


Now lets say I want to present this entire output as some color in the browser,
So whatever color is selected, 

so make following changes--

			out.print("<p style='color:" + color + "';>");			
			out.print("Hello, "+name);
			out.print("<br/>You have scored : "+marks);			
			out.print("</p>");
		
Now lets say we want to do some calc on this amrks value,
lets suppose we want to divide marks by 500 to calc what is the aggregate.
For this marks value has to be in proper foramt first and not in String type.

getParameter() returns value in Stirng form.We will do typecasting. thirdservlet.java


	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			String name = req.getParameter("name");
			float marks = Float.parseFloat(req.getParameter("marks"));
			String color = req.getParameter("color");
			float aggregate = (marks/500)*100;
			
			out.print("<p style='color:" + color + "';>");			
			out.print("Hello, "+name);
			out.print("<br/>You have scored : "+aggregate + "%");			
			out.print("</p>");
		
	}


--

Now lets say I don't want to send empty string or missing value.
And if value is not sent the eroor msg should come

So we will not create complete form by using html page, instead by HttpServlet.

We can setup our servlet as homepage.

So we will create a new servlet--  So now we will see validation part.

new-->dynamic web project-->project name-->ValidationApp

now, right click validation app->new ->java class->package-- com.itvedant , file name-- HomeServlet

package com.itvedant;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HomeServlet extends HttpServlet{
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO Auto-generated method stub
		super.doGet(req, resp);
	}
	
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(req, resp);
	}
}


this is waht we have done till now.

Now, if the req is coming directly to HomeServlet, so we will need to set url.
For that we will need web.xml file.

Now right click on project folder-->java ee tools-->generate deployment descriptor stub--
so now in src->web-inf folder, web.xml file is ready.

Here, welcome file list,we will map srvlet

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>ValidationApp</display-name>
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>
  <servlet>
	<servlet-name>Home</servlet-name>
	<servlet-class>com.itvedant.HomeServlet</servlet-class>	
  </servlet>
  <servlet-mapping>
	<servlet-name>Home</servlet-name>
	<url-pattern>/home</url-pattern>
  </servlet-mapping>
</web-app>

now 1st time when we will run , it will give me error, because we have not created those files yet.

Now lets say in HOmeServlet under, doGet() we have written--

public class HomeServlet extends HttpServlet{
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = resp.getWriter();
		resp.setContentType("text/html");
		out.println("Welcome");
}

run as-- http://localhost:8080/ValidationApp/home

Now if you want directly the req should go to home page only,
so, in web.xml file--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>ValidationApp</display-name>
  
  <servlet>
	<servlet-name>Home</servlet-name>
	<servlet-class>com.itvedant.HomeServlet</servlet-class>	
  </servlet>
  <servlet-mapping>
	<servlet-name>Home</servlet-name>
	<url-pattern>/home</url-pattern>
  </servlet-mapping>
  <welcome-file-list>
    <welcome-file>home</welcome-file>
    
  </welcome-file-list>
</web-app>


So now our req is going directly to home servlet.
Now copy form from home.html to HomeServlet.java bcoz we want to create form.
So make the changes in HomeServlet.java

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HomeServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		PrintWriter out = resp.getWriter();
		resp.setContentType("text/html");
		
		out.print("<form action='validate' method='get'>");
		out.print("<table><tr><td>Name:</td>");
		out.print("<td><input type='text' name='name'/></td>");
		out.print("</tr><tr><td>Marks:</td>");
		out.print("<td><input type='number' name='marks'/></td>");
		out.print("</tr><tr><td>Color:</td><td>");
		out.print("<select name='color'>");
		out.print("<option value='none'>.....</option>");
		out.print("<option>Red</option>");
		out.print("<option>Blue</option>");
		out.print("<option>Green</option>");
		out.print("<option>Pink</option>");
		out.print("<option>Purple</option>");
		out.print("<option>Grey</option>");
		out.print("<option>Violet</option>");
		out.print("<option>Indigo</option>");
		out.print("</select></td></tr><tr>");
		out.print("<td><input type='submit' value='OK'/></td>");
		out.print("<td><input type='reset'/></td></tr></table></form>");
	}
	
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		doGet(req, resp);
	}
}


now,creatting into servlet is not an easy task, so we will be using jsp--

Now, we directly have an option of creating servlet.
The adv here is we donot have to create java file then servlet.

So, right click project->new->servlet-->package-- com.itvedant-->class name-->ValidateServlet

so name of my servlet will be automatically set to ValidateServlet

-->next-->now name u can change to Validate-->now in url mapping bcoz V in validate is capital,
so, click Validate in url mapping-->edit make it validate.-->ok-->next-->click the methods u want-->finish

now, keep these functions remove others, if u want to keep that is also fine.

@WebServlet(name = "Validate", urlPatterns = { "/validate" })-- in this line we mapped 
the servlet class with the url,so that the web container can send the request to the requested servlet.
For this 1 way is web.xml file. Here create a deployment descriptor file and do the url mapping.
2nd way --annotation-- @WebServlet above the servlet class. Here u donot need to write anything in web.xml file.

http://localhost:8080/ValidationApp/validate

Now changing the doGet() to see if its actually coming here,

Now we will try to validate data, that our name field is not empty,

ValidateServlet.java

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ValidateServlet
 */
@WebServlet(name = "Validate", urlPatterns = { "/validate" })
public class ValidateServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = response.getWriter();
		response.setContentType("text/html");
		
		String name = request.getParameter("name");
		if(name.equals("")) {
			out.print("<br/>Name not provided");
		}
		String marks = request.getParameter("marks");
		if(marks.equals("")) {
			out.print("<br/>Marks not provided");
		}
		String colo = request.getParameter("color");
		if(colo.equals("none")) {
			out.print("<br/>Color not selected");
		}
		
		out.print("<br/>Validate Servlet Reached");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


run as-- http://localhost:8080/ValidationApp/

donot give any value and see error.

Now we want error msgs come back to index page only. and not on other page.

so we will create a list--

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ValidateServlet
 */
@WebServlet(name = "Validate", urlPatterns = { "/validate" })
public class ValidateServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = response.getWriter();
		response.setContentType("text/html");
		List<String> errorList = new ArrayList<String>();
		String name = request.getParameter("name");
		if(name.equals("")) {
			errorList.add("Name not provided");
			
		}
		String marks = request.getParameter("marks");
		if(marks.equals("")) {
			errorList.add("Marks not provided");
		}
		String colo = request.getParameter("color");
		if(colo.equals("none")) {
			errorList.add("Color not provided");
		}
		if(errorList.isEmpty()) {
			request.getRequestDispatcher("success").forward(request, response);
		}
		else {
			
		}
		
		out.print("<br/>Validate Servlet Reached");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}



now lets say my data is fine and their is no error, then,
but in case of error we will do 2 types of operations using an interface called req dispatcher.

1st task-- req is given to servlet1, which gives name,marks and color.
Now, we will forward all the req to servelet2. The res that we will finally get,
we will get from servlet2.

Now lets give this task name as success servlet.

new->servlet-->java package-->com.itvedant-->Class name-->SuccessServlet-->next-->Sucess-->/success-->finish

now, from home servlet, we r bringing 3 things to validate servlet.

now if no error is there then in ValidateServlet.java errorlist is empty.
and we will forward our req to SuccessServlet.

if(errorList.isEmpty()) {
			request.getRequestDispatcher("success").forward(request, response); // fwd my req to success servlet
		}

SuccessServlet.java--

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		out.print("Success");
	}

run--> fill all the values-->success

Now on success page we want to fill all the details.

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(name = "Success", urlPatterns = { "/success" })
public class SuccessServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
  
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		//out.print("Success");
		String name = request.getParameter("name");
		String marks = request.getParameter("marks");
		String color = request.getParameter("color");
		
		out.print("<p style='color : " + color + ";'>");
		out.print("Welcome , "+name);
		out.print("<br/><br/> You have scored "+ marks);
		out.print("</p>");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


run as-- fill all the values-->ok. So here we forwarded our req from 1 servlet to another.

Now if u want to show aggregaate then on validate page only, u can also calc the aggregate and forward it to succes page.

So, ValidateServlet.java

	if(errorList.isEmpty()) {
			float m = Float.parseFloat(marks);
			// now this aggregate and m are local variable. We need to forward this local variable to
			// another servlet
			float aggregate = (m/500)*100;
			request.getRequestDispatcher("success").forward(request, response);
		}

now to forward req from servlet1 to 2, we r using forward().
We can also add our local variable in our RequestDispatcher only.

}
		if(errorList.isEmpty()) {
			float m = Float.parseFloat(marks);
			// now this aggregate and m are local variable. We need to forward this local variable to
			// another servlet
			float aggregate = (m/500)*100;
			
			// adding local variable in request.
			request.setAttribute("aggr", aggregate);------------------------------ aggregate will be identified as aggr in another servlet.
			request.getRequestDispatcher("success").forward(request, response);
		}


So going into successservlet--

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(name = "Success", urlPatterns = { "/success" })
public class SuccessServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
  
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		//out.print("Success");
		String name = request.getParameter("name");
		String marks = request.getParameter("marks");
		String color = request.getParameter("color");
		float aggregate = (float)request.getAttribute("aggr"); //----------------------
		
		out.print("<p style='color : " + color + ";'>");
		out.print("Welcome , "+name);
		out.print("<br/><br/> You have scored "+ marks);
		out.print("<br/><br/> Your aggregate is "+ aggregate + "%"); //--------------------
		out.print("</p>");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}

So what we did is-- 1st we r going to home servlet-->then to validate servlet where we r reading each req
, if there is no error and all the values are provided---> then to success servlet

Here the browser is not aware about this transition. This entire process is happening within server.
For browser, when we give all the input, input is going to validate.
But internally it is getting forwarded from validate to success. 
U can see the url. URL is not getting updated with success


What if we want to make browser aware about thi that is--
if we want to move control from 1 servlet to another we can do using 3 techniques.

1. using forward() of RequestDispatcher
2. using include() of RequestDispatcher
3. sendRedirect of HttpRequest

1. forward() of RequestDispatcher

The request of the current servlet is dispatched to another servlet specified. This transition is happening inside the server, 
the client ie. hence browser is not aware about this transition and will not update the URL accordingly

2. include() of RequestDispatcher

The response of the another servlet in included within the first servlet request. Here the final response is generated by the first servlet

3. sendRedirect of HttpServletResponse

The control will move from one servlet to another servlet specified.
 Here the transition will not happen within the server instead the client will issue a new request for the second servlet, 
hence the client is aware about the transition and will update the URL accordingly. 
But here the request of the first servlet is not send to the second servlet.

So lets say in case of error in validateservlet.java, i want my req to send back to home page,

so, ValidateServlet.java

	else {
			response.sendRedirect("home");
		}
		
So, now run-- just click ok, dont put any value. -- It is not going at validate page.

So to just distinguish, 
	else {
			response.sendRedirect("home?redirect=yes");
		}

just to understand that it is getting redirected.

run-- in case of error-- see the url.
so, in sendRedirect, url is aware. So its like a fresh req to another servlet.
So if u just want to do movement from 1 page to another use sendRedirect
and if u want to pass data the use forward().

Now lets say i want to goto my home page but I want to tell user about these errors.
i.e. i want to print my error list.
So next we will see include()---
for this i dont want to pass req from 1 servlet to another instead i will include
home servlet response under validate servlet.
where, the home servlet response is the form page which we r getting.
So here the req is not coming in the picture instead resp is coming.

So, we r sending req to home page. Now if errors are there i am printing my errors.
and after printing errors, home page should be reconstructed,this we will do
by including home servlet within my validate servlet.
We will not rewrite entire home code. So in this case,
servlet2 is home page which is included as response to servlet1 which is validate page.

So the compbined response of servlet1 and servlet2 is given as final response. ValidateServlet.java

	else {
			//response.sendRedirect("home?redirect=yes");
			out.print("<ul style='color:red;'>");
			for(String err:errorList) {
				out.print("<li>" + err + "</li>");
			}
			out.print("</ul>");
		}

run as-- do not provide any value and see.
errors are there. Now below these errors , I want my home page form reconstructed below this .

	else {
			//response.sendRedirect("home?redirect=yes");
			out.print("<ul style='color:red;'>");
			for(String err:errorList) {
				out.print("<li>" + err + "</li>");
			}
			out.print("</ul>");
			request.getRequestDispatcher("home").include(request,response);
			
		}

Now, run as-->give error--->see o/p.

so, wit the help of include, we r including the response of 1 servlet into our servlet.

--

Now to perform initialization, we have 2 interfaces.

1. ServletConfig
2. ServletContext

1 is used for entire application level initialization while another is used for only application level initialization.
So if we nedd some paramenters to be initialized before my servlet gets executed, for that these 2 parameters are used.

See earlier when we created FirstApp-->java resources-->FirstServlet.java--- see init() is there.
init() is taking 1 parameter that is of type ServletConfig. For every servlet, there is going to be 1 instance created for
servletconfig and it will be used to initialize the vaues required to be initialized and it is not sharable.

ServletConfig

Is an interface whose instance is created by the web container for each servlet. For every servlet, 
only one ServletConfig instance is created and is passed as the parameter to the init() method

This object contains initail parameter passed by the web container to the Servlet during initialization

Scope of this instance is restricted to the Servlet for which it is defined.

So now come back to HomeServlet--- the list that we generated using out.print(),
this doesn't need to be generated manually.
instead the value of the colors , we will put into ServletConfig initialization so it will become more dynamic.

So in ur web.xml-- define this as ur initial parameter.

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>ValidationApp</display-name>
  
  <servlet>
	<servlet-name>Home</servlet-name>
	<servlet-class>com.itvedant.HomeServlet</servlet-class>	
	<init-param>
		<param-name>colors</param-name>
		<param-value>Red,Blue,Yellow,Green,Purple,Pink,Indigo,Violet,Grey,Cyan,Magenta,Orange</param-value>
	</init-param>
  
  </servlet>
  <servlet-mapping>
	<servlet-name>Home</servlet-name>
	<url-pattern>/home</url-pattern>
  </servlet-mapping>
  <welcome-file-list>
    <welcome-file>home</welcome-file>
    
  </welcome-file-list>
</web-app>

Now we will extract <param-value>Red,Blue,Yellow,Green,Purple,Pink,Indigo,Violet,Grey,Cyan,Magenta,Orange</param-value>---- this is a single string.

Now, we r setting this initial parametr for home servlet. So vlidate and sucess servlet will not be able to acecess it.

So from homeservlet we r removing out.print red to indigo.

So the value we r setting in our initial parameter, we will be reading that first.

String colors = getInitParameter("colors");

since,in web.xml, we have setted it to colors.
so, colors has the entire list of param-value.

u can even print and check.

run as-- the entire color list is visible. But this we want in our drop off box.

So what we can do is we can seperate this list and create a string array.

		String colors = getInitParameter("colors");
		//out.print(colors);
		
		String[] colorVaues = colors.split(",");/----------------------------
		
		out.print("<form action='validate' method='get'>"); 

and print using for loop. So --


public class HomeServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		PrintWriter out = resp.getWriter();
		resp.setContentType("text/html");
		
		String colors = getInitParameter("colors");
		//out.print(colors);
		
		String[] colorValues = colors.split(",");
		
		out.print("<form action='validate' method='get'>");
		out.print("<table><tr><td>Name:</td>");
		out.print("<td><input type='text' name='name'/></td>");
		out.print("</tr><tr><td>Marks:</td>");
		out.print("<td><input type='number' name='marks'/></td>");
		out.print("</tr><tr><td>Color:</td><td>");
		out.print("<select name='color'>");
		out.print("<option value='none'>.....</option>");
		
		
		for(String c : colorValues) {
			out.print("<option>"+ c + "</option>");
		}
		
		out.print("</select></td></tr><tr>");
		out.print("<td><input type='submit' value='OK'/></td>");
		out.print("<td><input type='reset'/></td></tr></table></form>");
	}
	
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		doGet(req, resp);
	}
}

so on run as-- u will get drop down in colors.
give all the info--select color-- ok.
 But the thing is this is accessible only inside hoemservlet.

So now inside ValidateServlet--

and write something like this,
PrintWriter out = response.getWriter();
		response.setContentType("text/html");
		
		String colors = getInitParameter("colors");----------
		out.print(colors.charat(0));----------------------------------- doing some task-- it will give error.

		
		List<String> errorList = new ArrayList<String>();


we r getting NullPointException.

So remove above code from validateservlet.

So now we will talk about scope of data on servlet. ServletConfig has least scope and is accessible only inside single servlet.

Scope of the data in the servlet
1. ServletConfig: accessible only in the single servlet
2. HttpServletRequest: accessible in two servlets between which the request is transferred
3. HttpSession: 
4. ServletContext: accessible to the entire application means to all the Servlet & JSP of the application

ServletContext

Is an interface whose instance is created by the web container. Only one instance is created for the entire application (project). 
This instance is accessible to all the servlets and JSP of the project. 

We can initial the parameters in this object using web.xml or add the parameters in the servlet execution 








 








 